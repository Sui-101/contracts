/// SuiVerse Epoch Rewards Distribution System - REDESIGNED
/// 
/// Implements a unified deposit pool system with exact mathematical distribution:
/// - 50% to content creators (approved content only) - Score² based allocation
/// - 40% to validators - Consensus similarity based allocation  
/// - 10% to core treasury - Platform maintenance
/// 
/// All deposits from content creators flow into a single unified pool and are distributed
/// at epoch end using precise mathematical formulas for fair allocation.
module suiverse_content::epoch_rewards {
    use std::string::{String};
    use std::option::{Option};
    use std::vector;
    use sui::object::{ID, UID};
    use sui::tx_context::{TxContext};
    use sui::coin::{Self, Coin};
    use sui::sui::SUI;
    use sui::balance::{Self, Balance};
    use sui::event;
    use sui::table::{Table};
    use sui::clock::{Clock};
    use sui::transfer;
    
    // Dependencies
    use suiverse_core::treasury::{Treasury};
    use suiverse_content::config::{ContentConfig};
    
    // =============== Constants ===============
    
    // Error codes
    const E_NOT_AUTHORIZED: u64 = 9001;
    const E_EPOCH_NOT_READY: u64 = 9002;
    const E_REWARDS_ALREADY_DISTRIBUTED: u64 = 9003;
    const E_INSUFFICIENT_DEPOSITS: u64 = 9004;
    const E_INVALID_SCORE: u64 = 9005;
    const E_NO_APPROVED_CONTENT: u64 = 9006;
    const E_NO_ACTIVE_VALIDATORS: u64 = 9007;
    const E_CALCULATION_ERROR: u64 = 9008;
    const E_DISTRIBUTION_FAILED: u64 = 9009;
    const E_INVALID_EPOCH: u64 = 9010;
    const E_ALREADY_CLAIMED: u64 = 9011;
    const E_CLAIM_EXPIRED: u64 = 9012;
    const E_ZERO_DIVISION: u64 = 9013;
    
    // Distribution percentages (exact allocation - 100% total)
    const CREATOR_ALLOCATION_BP: u64 = 5000; // 50%
    const VALIDATOR_ALLOCATION_BP: u64 = 4000; // 40%
    const TREASURY_ALLOCATION_BP: u64 = 1000; // 10%
    const BASIS_POINTS: u64 = 10000; // 100% in basis points
    
    // Score calculation constants
    const MIN_SCORE_FOR_REWARDS: u64 = 70; // Minimum consensus score for rewards
    const MAX_SCORE: u64 = 100; // Maximum possible score
    const MIN_CONSENSUS_DEVIATION: u64 = 5; // Minimum deviation for similarity calculation
    
    // Reward types
    const REWARD_TYPE_CREATOR: u8 = 1;
    const REWARD_TYPE_VALIDATOR: u8 = 2;
    
    // Epoch and claim configuration
    const EPOCH_DURATION_MS: u64 = 86400000; // 24 hours
    const CLAIM_EXPIRY_MS: u64 = 604800000; // 7 days to claim rewards
    
    // Mathematical precision constants
    const PRECISION_FACTOR: u64 = 1000000; // For precise calculations
    const MIN_DEPOSIT_AMOUNT: u64 = 1000000; // Minimum 0.001 SUI deposit
    
    // =============== Structs ===============
    
    /// Unified deposit pool for an epoch (COMPLETE REDESIGN)
    public struct EpochRewardPool has key {
        id: UID,
        epoch_number: u64,
        epoch_start_time: u64,
        epoch_end_time: u64,
        
        // UNIFIED DEPOSIT POOL - Single source of truth
        total_deposits: Balance<SUI>,
        total_deposit_count: u64,
        
        // Creator tracking for Score² allocation
        creator_deposits: Table<address, CreatorDeposit>,
        approved_creators: vector<address>,
        total_score_squared_sum: u64, // Sum of all approved creators' score²
        
        // Validator tracking for consensus similarity
        validator_activities: Table<address, ValidatorActivity>,
        active_validators: vector<address>,
        total_validator_weight: u64, // Sum of all validator similarity weights
        
        // Calculated distribution amounts (50% + 40% + 10% = 100%)
        creator_pool_amount: u64,     // 50% of total_deposits
        validator_pool_amount: u64,   // 40% of total_deposits  
        treasury_fee_amount: u64,     // 10% of total_deposits
        
        // Distribution state
        rewards_calculated: bool,
        rewards_distributed: bool,
        distribution_timestamp: Option<u64>,
        
        // Admin capability
        admin: address,
    }
    
    /// Individual creator deposit and performance data (REDESIGNED)
    public struct CreatorDeposit has store {
        creator: address,
        deposit_amount: u64,
        content_id: ID,
        
        // Approval status and consensus metrics
        consensus_score: u64,
        is_approved: bool,
        validator_count: u64,
        
        // Score² calculation for differential rewards
        score_squared: u64,  // consensus_score² for reward calculation
        individual_reward_amount: u64, // Calculated reward amount
        
        // Timestamps
        submitted_at: u64,
        reviewed_at: u64,
    }
    
    /// Validator activity and consensus similarity tracking (REDESIGNED)
    public struct ValidatorActivity has store {
        validator: address,
        reviews_completed: u64,
        
        // Consensus similarity calculation data
        review_scores: vector<u64>,     // All scores given by this validator
        final_consensus_scores: vector<u64>, // Final consensus scores for reviewed content
        similarity_weight: u64,         // Weight based on consensus similarity
        
        // Reward calculation
        individual_reward_amount: u64,  // Calculated reward amount
        
        // Performance tracking
        average_deviation_from_consensus: u64,
        total_review_time: u64,
    }
    
    /// Individual reward claim ticket (SIMPLIFIED)
    public struct RewardClaim has key, store {
        id: UID,
        recipient: address,
        epoch: u64,
        reward_type: u8, // 1=creator, 2=validator
        reward_amount: u64,
        
        // Performance context for transparency
        performance_score: u64,
        calculation_basis: String, // "score_squared" or "consensus_similarity"
        
        // Claim management
        created_at: u64,
        expires_at: u64,
        claimed: bool,
        claimed_at: Option<u64>,
    }
    
    /// Complete reward calculation results for transparency
    public struct RewardCalculation has store {
        epoch: u64,
        calculation_timestamp: u64,
        
        // Total deposit breakdown (100% allocation)
        total_deposit_amount: u64,
        creator_pool_amount: u64,     // 50%
        validator_pool_amount: u64,   // 40%
        treasury_fee_amount: u64,     // 10%
        
        // Creator calculations (Score² based)
        total_approved_creators: u64,
        total_score_squared_sum: u64,
        average_consensus_score: u64,
        
        // Validator calculations (Consensus similarity based)
        total_active_validators: u64,
        total_validator_weight: u64,
        average_similarity_score: u64,
        
        // Verification (should sum to 100%)
        allocation_verification: bool,
        calculation_method: String,
    }
    
    /// Epoch reward distribution manager (SIMPLIFIED)
    public struct RewardDistributor has key {
        id: UID,
        
        // Current epoch tracking
        current_epoch: u64,
        current_pool_id: Option<ID>,
        
        // Historical data
        epoch_pools: Table<u64, ID>,
        completed_epochs: vector<u64>,
        
        // System statistics
        total_epochs_processed: u64,
        total_deposits_processed: u64,
        total_rewards_distributed: u64,
        
        // Configuration
        admin: address,
    }
    
    // =============== Events ===============
    
    public struct EpochRewardPoolCreated has copy, drop {
        epoch: u64,
        pool_id: ID,
        epoch_start_time: u64,
        epoch_end_time: u64,
        timestamp: u64,
    }
    
    public struct CreatorDepositCollected has copy, drop {
        epoch: u64,
        creator: address,
        content_id: ID,
        deposit_amount: u64,
        total_deposits_now: u64,
        timestamp: u64,
    }
    
    public struct ValidatorActivityRecorded has copy, drop {
        epoch: u64,
        validator: address,
        content_id: ID,
        review_score: u64,
        consensus_score: u64,
        similarity_score: u64,
        timestamp: u64,
    }
    
    public struct EpochRewardsCalculated has copy, drop {
        epoch: u64,
        total_deposits: u64,
        creator_pool_amount: u64,      // 50%
        validator_pool_amount: u64,    // 40%  
        treasury_fee_amount: u64,      // 10%
        approved_creators: u64,
        total_score_squared_sum: u64,
        active_validators: u64,
        total_validator_weight: u64,
        verification_passed: bool,     // Confirms 100% allocation
        timestamp: u64,
    }
    
    public struct EpochDistributionCompleted has copy, drop {
        epoch: u64,
        total_deposits_distributed: u64,
        creator_claims_created: u64,
        validator_claims_created: u64,
        treasury_fee_transferred: u64,
        timestamp: u64,
    }
    
    public struct CreatorRewardCalculated has copy, drop {
        epoch: u64,
        creator: address,
        content_id: ID,
        consensus_score: u64,
        score_squared: u64,
        reward_amount: u64,
        percentage_of_creator_pool: u64, // In basis points
        timestamp: u64,
    }
    
    public struct ValidatorRewardCalculated has copy, drop {
        epoch: u64,
        validator: address,
        reviews_completed: u64,
        similarity_weight: u64,
        reward_amount: u64,
        percentage_of_validator_pool: u64, // In basis points
        timestamp: u64,
    }
    
    public struct RewardCalculationCompleted has copy, drop {
        epoch: u64,
        total_validators: u64,
        total_authors: u64,
        total_rewards_calculated: u64,
        processing_time_ms: u64,
        timestamp: u64,
    }
    
    public struct RewardClaimCreated has copy, drop {
        claim_id: ID,
        recipient: address,
        epoch: u64,
        reward_type: u8,
        amount: u64,
        bundled_amount: u64,
        expires_at: u64,
        timestamp: u64,
    }
    
    public struct RewardsClaimed has copy, drop {
        claim_id: ID,
        recipient: address,
        epoch: u64,
        total_amount: u64,
        reward_types: vector<u8>,
        performance_tier: Option<u8>,
        timestamp: u64,
    }
    
    public struct BonusAwarded has copy, drop {
        recipient: address,
        bonus_type: u8,
        amount: u64,
        performance_score: u64,
        performance_tier: u8,
        epoch: u64,
        reason: String,
        timestamp: u64,
    }
    
    public struct EpochRewardsDistributed has copy, drop {
        epoch: u64,
        total_validators_rewarded: u64,
        total_authors_rewarded: u64,
        validator_rewards: u64,
        author_rewards: u64,
        total_bonuses: u64,
        distribution_efficiency: u64,
        timestamp: u64,
    }
    
    public struct DistributionBatchProcessed has copy, drop {
        epoch: u64,
        batch_index: u64,
        claims_processed: u64,
        successful_claims: u64,
        failed_claims: u64,
        batch_processing_time: u64,
        timestamp: u64,
    }
    
    // =============== Init Function ===============
    
    fun init(ctx: &mut TxContext) {
        let admin = tx_context::sender(ctx);
        
        // Create epoch reward distribution manager
        let distributor = RewardDistributor {
            id: object::new(ctx),
            current_epoch: 1,
            current_pool_id: option::none(),
            epoch_pools: table::new(ctx),
            completed_epochs: vector::empty(),
            total_epochs_processed: 0,
            total_deposits_processed: 0,
            total_rewards_distributed: 0,
            admin,
        };
        
        transfer::share_object(distributor);
    }
    
    // =============== Epoch Management ===============
    
    /// Create new epoch deposit pool
    public entry fun create_epoch_reward_pool(
        config: &ContentConfig,
        distributor: &mut RewardDistributor,
        epoch_number: u64,
        epoch_start_time: u64,
        epoch_end_time: u64,
        _total_validator_rewards: u64, // Unused in new system
        _total_author_rewards: u64, // Unused in new system
        _total_bonus_rewards: u64, // Unused in new system
        clock: &Clock,
        ctx: &mut TxContext,
    ) {
        assert!(tx_context::sender(ctx) == distributor.admin, E_NOT_AUTHORIZED);
        assert!(epoch_number > distributor.current_epoch || distributor.current_epoch == 1, E_INVALID_EPOCH);
        
        let current_time = clock::timestamp_ms(clock);
        
        // Create unified deposit pool
        let pool = EpochRewardPool {
            id: object::new(ctx),
            epoch_number,
            epoch_start_time,
            epoch_end_time,
            total_deposits: balance::zero(),
            total_deposit_count: 0,
            creator_deposits: table::new(ctx),
            approved_creators: vector::empty(),
            total_score_squared_sum: 0,
            validator_activities: table::new(ctx),
            active_validators: vector::empty(),
            total_validator_weight: 0,
            creator_pool_amount: 0,
            validator_pool_amount: 0,
            treasury_fee_amount: 0,
            rewards_calculated: false,
            rewards_distributed: false,
            distribution_timestamp: option::none(),
            admin: tx_context::sender(ctx),
        };
        
        let pool_id = object::id(&pool);
        
        // Update distributor
        distributor.current_epoch = epoch_number;
        distributor.current_pool_id = option::some(pool_id);
        table::add(&mut distributor.epoch_pools, epoch_number, pool_id);
        
        // Emit event
        event::emit(EpochRewardPoolCreated {
            epoch: epoch_number,
            pool_id,
            epoch_start_time,
            epoch_end_time,
            timestamp: current_time,
        });
        
        transfer::share_object(pool);
    }
    
    /// Calculate and prepare rewards for epoch
    public entry fun calculate_epoch_rewards(
        reward_pool: &mut EpochRewardPool,
        distributor: &mut RewardDistributor,
        config: &ContentConfig,
        clock: &Clock,
        ctx: &mut TxContext,
    ) {
        let current_time = clock::timestamp_ms(clock);
        assert!(!reward_pool.distribution_started, E_REWARDS_ALREADY_DISTRIBUTED);
        
        let calculation_start = current_time;
        
        // Mark distribution as started
        reward_pool.distribution_started = true;
        distributor.current_epoch_processing = option::some(reward_pool.epoch_number);
        distributor.current_batch_index = 0;
        distributor.distribution_progress = 0;
        
        // Calculate validator rewards
        let validator_rewards = calculate_validator_rewards(
            reward_pool,
            config,
            current_time
        );
        
        // Calculate author rewards
        let author_rewards = calculate_author_rewards(
            reward_pool,
            config,
            current_time
        );
        
        // Store pending rewards
        distributor.pending_validator_rewards = validator_rewards;
        distributor.pending_author_rewards = author_rewards;
        
        let calculation_time = current_time - calculation_start;
        
        // Emit calculation completed event
        event::emit(RewardCalculationCompleted {
            epoch: reward_pool.epoch_number,
            total_validators: vector::length(&distributor.pending_validator_rewards),
            total_authors: vector::length(&distributor.pending_author_rewards),
            total_rewards_calculated: balance::value(&reward_pool.validator_base_pool) + 
                                    balance::value(&reward_pool.author_base_pool),
            processing_time_ms: calculation_time,
            timestamp: current_time,
        });
    }
    
    /// Distribute rewards in batches
    public entry fun distribute_epoch_rewards_batch(
        reward_pool: &mut EpochRewardPool,
        distributor: &mut RewardDistributor,
        treasury: &mut Treasury,
        clock: &Clock,
        ctx: &mut TxContext,
    ) {
        let current_time = clock::timestamp_ms(clock);
        assert!(reward_pool.distribution_started, E_EPOCH_NOT_READY);
        assert!(!reward_pool.distribution_completed, E_REWARDS_ALREADY_DISTRIBUTED);
        
        let batch_start = current_time;
        let mut claims_processed = 0u64;
        let mut successful_claims = 0u64;
        let mut failed_claims = 0u64;
        
        // Process validator rewards batch
        let validator_batch_size = distributor.batch_size / 2; // Split batch between validators and authors
        claims_processed = claims_processed + process_validator_rewards_batch(
            reward_pool,
            distributor,
            validator_batch_size,
            &mut successful_claims,
            &mut failed_claims,
            current_time,
            ctx
        );
        
        // Process author rewards batch
        let author_batch_size = distributor.batch_size - validator_batch_size;
        claims_processed = claims_processed + process_author_rewards_batch(
            reward_pool,
            distributor,
            author_batch_size,
            &mut successful_claims,
            &mut failed_claims,
            current_time,
            ctx
        );
        
        // Update progress
        let total_pending = vector::length(&distributor.pending_validator_rewards) + 
                          vector::length(&distributor.pending_author_rewards);
        
        if (total_pending == 0) {
            // Distribution completed
            reward_pool.distribution_completed = true;
            reward_pool.distribution_timestamp = option::some(current_time);
            distributor.current_epoch_processing = option::none();
            distributor.distribution_progress = 100;
            
            // Emit completion event
            event::emit(EpochRewardsDistributed {
                epoch: reward_pool.epoch_number,
                total_validators_rewarded: reward_pool.validators_rewarded,
                total_authors_rewarded: reward_pool.authors_rewarded,
                validator_rewards: 0, // Would calculate total
                author_rewards: 0, // Would calculate total
                total_bonuses: 0, // Would calculate total
                distribution_efficiency: (successful_claims * 100) / (successful_claims + failed_claims),
                timestamp: current_time,
            });
        } else {
            // Update progress percentage
            let processed = distributor.distributions_completed;
            let total = processed + total_pending;
            distributor.distribution_progress = (processed * 100) / total;
        };
        
        let batch_time = current_time - batch_start;
        distributor.current_batch_index = distributor.current_batch_index + 1;
        
        // Update performance metrics
        distributor.total_processing_time = distributor.total_processing_time + batch_time;
        distributor.average_batch_time = distributor.total_processing_time / distributor.current_batch_index;
        
        // Emit batch processed event
        event::emit(DistributionBatchProcessed {
            epoch: reward_pool.epoch_number,
            batch_index: distributor.current_batch_index,
            claims_processed,
            successful_claims,
            failed_claims,
            batch_processing_time: batch_time,
            timestamp: current_time,
        });
    }
    
    // =============== Reward Calculation ===============
    
    /// Calculate validator rewards for the epoch
    fun calculate_validator_rewards(
        reward_pool: &mut EpochRewardPool,
        config: &ContentConfig,
        current_time: u64,
    ): vector<ValidatorRewardData> {
        let mut validator_rewards = vector::empty<ValidatorRewardData>();
        
        // For now, simplified implementation
        // In full implementation, would iterate through all validators and calculate based on performance
        
        reward_pool.total_validators_eligible = 0; // Would count eligible validators
        validator_rewards
    }
    
    /// Calculate author rewards for the epoch
    fun calculate_author_rewards(
        reward_pool: &mut EpochRewardPool,
        config: &ContentConfig,
        current_time: u64,
    ): vector<AuthorRewardData> {
        let mut author_rewards = vector::empty<AuthorRewardData>();
        
        // For now, simplified implementation
        // In full implementation, would iterate through all authors and calculate based on approved articles
        
        reward_pool.total_authors_eligible = 0; // Would count eligible authors
        author_rewards
    }
    
    /// Calculate performance-based bonuses for validator
    fun calculate_validator_bonuses(
        reward_data: &ValidatorRewardData,
        reward_pool: &EpochRewardPool,
    ): (u64, u64, u64, u64) {
        let mut quality_bonus = 0u64;
        let mut speed_bonus = 0u64;
        let mut consistency_bonus = 0u64;
        let mut accuracy_bonus = 0u64;
        
        // Quality bonus based on average quality scores
        if (vector::length(&reward_data.quality_scores) > 0) {
            let avg_quality = calculate_average_quality(&reward_data.quality_scores);
            if (avg_quality >= QUALITY_THRESHOLD) {
                quality_bonus = (QUALITY_BONUS_MAX * (avg_quality - QUALITY_THRESHOLD)) / (100 - QUALITY_THRESHOLD);
            };
        };
        
        // Speed bonus based on average review time
        if (reward_data.reviews_completed > 0) {
            let avg_time = reward_data.total_review_time / reward_data.reviews_completed;
            if (avg_time <= SPEED_THRESHOLD_MS) {
                speed_bonus = SPEED_BONUS_MAX;
            };
        };
        
        // Consistency bonus based on regular participation
        if (reward_data.reviews_completed >= MIN_REVIEWS_FOR_BONUS) {
            consistency_bonus = CONSISTENCY_BONUS_MAX;
        };
        
        // Accuracy bonus based on consensus alignment
        if (reward_data.reviews_completed > 0) {
            let accuracy_rate = (reward_data.consensus_alignments * 100) / reward_data.reviews_completed;
            if (accuracy_rate >= ACCURACY_THRESHOLD) {
                accuracy_bonus = ACCURACY_BONUS_MAX;
            };
        };
        
        (quality_bonus, speed_bonus, consistency_bonus, accuracy_bonus)
    }
    
    /// Calculate tier-based multiplier
    fun calculate_tier_multiplier(performance_tier: u8): u64 {
        match (performance_tier) {
            1 => BRONZE_MULTIPLIER,
            2 => SILVER_MULTIPLIER,
            3 => GOLD_MULTIPLIER,
            4 => PLATINUM_MULTIPLIER,
            _ => BRONZE_MULTIPLIER,
        }
    }
    
    // =============== Batch Processing ===============
    
    /// Process validator rewards in batch
    fun process_validator_rewards_batch(
        reward_pool: &mut EpochRewardPool,
        distributor: &mut RewardDistributor,
        batch_size: u64,
        successful_claims: &mut u64,
        failed_claims: &mut u64,
        current_time: u64,
        ctx: &mut TxContext,
    ): u64 {
        let mut processed = 0u64;
        let pending = &mut distributor.pending_validator_rewards;
        
        while (processed < batch_size && !vector::is_empty(pending)) {
            let reward_data = vector::pop_back(pending);
            
            match (create_validator_reward_claim(reward_pool, &reward_data, current_time, ctx)) {
                true => *successful_claims = *successful_claims + 1,
                false => *failed_claims = *failed_claims + 1,
            };
            
            processed = processed + 1;
        };
        
        processed
    }
    
    /// Process author rewards in batch
    fun process_author_rewards_batch(
        reward_pool: &mut EpochRewardPool,
        distributor: &mut RewardDistributor,
        batch_size: u64,
        successful_claims: &mut u64,
        failed_claims: &mut u64,
        current_time: u64,
        ctx: &mut TxContext,
    ): u64 {
        let mut processed = 0u64;
        let pending = &mut distributor.pending_author_rewards;
        
        while (processed < batch_size && !vector::is_empty(pending)) {
            let reward_data = vector::pop_back(pending);
            
            match (create_author_reward_claim(reward_pool, &reward_data, current_time, ctx)) {
                true => *successful_claims = *successful_claims + 1,
                false => *failed_claims = *failed_claims + 1,
            };
            
            processed = processed + 1;
        };
        
        processed
    }
    
    // =============== Claim Creation ===============
    
    /// Create reward claim for validator
    fun create_validator_reward_claim(
        reward_pool: &mut EpochRewardPool,
        reward_data: &ValidatorRewardData,
        current_time: u64,
        ctx: &mut TxContext,
    ): bool {
        // Check if sufficient funds available
        if (balance::value(&reward_pool.validator_base_pool) < reward_data.total_reward) {
            return false
        };
        
        // Create bundled reward claim
        let mut claim = RewardClaim {
            id: object::new(ctx),
            recipient: reward_data.validator,
            epoch: reward_pool.epoch_number,
            reward_type: REWARD_TYPE_VALIDATOR_BASE,
            amount: reward_data.base_reward,
            article_id: option::none(),
            session_id: option::none(),
            performance_tier: option::some(reward_data.performance_tier),
            performance_score: option::none(),
            bonus_reason: option::none(),
            created_at: current_time,
            expires_at: current_time + CLAIM_EXPIRY_MS,
            claimed: false,
            claimed_at: option::none(),
            bundled_rewards: table::new(ctx),
            total_bundled_amount: 0,
        };
        
        // Add bonuses to bundled rewards
        let mut total_bundled = 0u64;
        
        if (reward_data.quality_bonus > 0) {
            table::add(&mut claim.bundled_rewards, REWARD_TYPE_QUALITY_BONUS, reward_data.quality_bonus);
            total_bundled = total_bundled + reward_data.quality_bonus;
        };
        
        if (reward_data.speed_bonus > 0) {
            table::add(&mut claim.bundled_rewards, REWARD_TYPE_SPEED_BONUS, reward_data.speed_bonus);
            total_bundled = total_bundled + reward_data.speed_bonus;
        };
        
        if (reward_data.consistency_bonus > 0) {
            table::add(&mut claim.bundled_rewards, REWARD_TYPE_CONSISTENCY_BONUS, reward_data.consistency_bonus);
            total_bundled = total_bundled + reward_data.consistency_bonus;
        };
        
        if (reward_data.accuracy_bonus > 0) {
            table::add(&mut claim.bundled_rewards, REWARD_TYPE_ACCURACY_BONUS, reward_data.accuracy_bonus);
            total_bundled = total_bundled + reward_data.accuracy_bonus;
        };
        
        claim.total_bundled_amount = total_bundled;
        
        let claim_id = object::id(&claim);
        
        // Update pool counters
        reward_pool.validators_rewarded = reward_pool.validators_rewarded + 1;
        
        // Emit claim created event
        event::emit(RewardClaimCreated {
            claim_id,
            recipient: reward_data.validator,
            epoch: reward_pool.epoch_number,
            reward_type: REWARD_TYPE_VALIDATOR_BASE,
            amount: reward_data.base_reward,
            bundled_amount: total_bundled,
            expires_at: claim.expires_at,
            timestamp: current_time,
        });
        
        transfer::public_transfer(claim, reward_data.validator);
        true
    }
    
    /// Create reward claim for author
    fun create_author_reward_claim(
        reward_pool: &mut EpochRewardPool,
        reward_data: &AuthorRewardData,
        current_time: u64,
        ctx: &mut TxContext,
    ): bool {
        // Check if sufficient funds available
        if (balance::value(&reward_pool.author_base_pool) < reward_data.total_reward) {
            return false
        };
        
        // Create bundled reward claim
        let mut claim = RewardClaim {
            id: object::new(ctx),
            recipient: reward_data.author,
            epoch: reward_pool.epoch_number,
            reward_type: REWARD_TYPE_AUTHOR_BASE,
            amount: reward_data.base_reward,
            article_id: option::none(),
            session_id: option::none(),
            performance_tier: option::none(),
            performance_score: option::some(reward_data.total_consensus_score),
            bonus_reason: option::none(),
            created_at: current_time,
            expires_at: current_time + CLAIM_EXPIRY_MS,
            claimed: false,
            claimed_at: option::none(),
            bundled_rewards: table::new(ctx),
            total_bundled_amount: 0,
        };
        
        // Add bonuses to bundled rewards
        let mut total_bundled = 0u64;
        
        
        if (reward_data.innovation_bonus > 0) {
            table::add(&mut claim.bundled_rewards, REWARD_TYPE_INNOVATION_BONUS, reward_data.innovation_bonus);
            total_bundled = total_bundled + reward_data.innovation_bonus;
        };
        
        claim.total_bundled_amount = total_bundled;
        
        let claim_id = object::id(&claim);
        
        // Update pool counters
        reward_pool.authors_rewarded = reward_pool.authors_rewarded + 1;
        
        // Emit claim created event
        event::emit(RewardClaimCreated {
            claim_id,
            recipient: reward_data.author,
            epoch: reward_pool.epoch_number,
            reward_type: REWARD_TYPE_AUTHOR_BASE,
            amount: reward_data.base_reward,
            bundled_amount: total_bundled,
            expires_at: claim.expires_at,
            timestamp: current_time,
        });
        
    // Note: Old claim creation functions removed - replaced with unified distribution logic
    
    // Note: Old functions removed - all functionality moved to unified distribution system above

    // Note: View functions defined in main body above
    
    // Note: Content approval status function defined in main body above
    
    // Note: Validator activity function defined in main body above
    
    // Note: All view functions defined in main body above
    
    // Note: Admin functions defined in main body above
    
    // Note: Test functions already included above

    // Note: All comprehensive test functions included above
}